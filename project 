Техническое задание (ТЗ): JSRVIS 1C Mobile
1. Цель проекта
Создание мобильного AI-агента для управления бизнес-процессами в 1С. Система должна преобразовывать неструктурированный ввод (голос, фото, чат) в структурированные вызовы API 1С и предоставлять аналитическую поддержку через RAG (базу знаний).
2. Основные модули
Голосовой интерфейс (Jarvis Voice): Запись аудио через expo-av, транскрибация через Whisper и выполнение команд.
Зрение (Jarvis Vision): Анализ фото накладных и ценников через GPT-4o-mini для автоматического создания документов.
Библиотекарь (RAG): Поиск по внутренним инструкциям и регламентам компании из Qdrant.
Интегратор 1С: Прослойка на Nest.js, которая авторизует запросы и переводит намерения AI в OData или HTTP-запросы к 1С.
3. Технические требования
Авторизация через Phone OTP (Supabase).
Поддержка Offline-first для просмотра остатков (Zustand + Persist).
Стриминг ответов LLM для улучшения UX (Vercel AI SDK).
Структура проекта (Monorepo-style в Replit)
Для ускорения разработки мы организуем код так, чтобы типизация была сквозной./jsrvis-1c-mobile
├── apps
│   ├── mobile (Expo Project)
│   │   ├── src
│   │   │   ├── components (UI: Chat, VoiceButton, CameraScanner)
│   │   │   ├── hooks (useJarvis, use1C, useVoice)
│   │   │   ├── store (Zustand: authStore, inventoryStore)
│   │   │   └── services (API wrappers)
│   │   └── app.json (Expo config)
│   └── server (Nest.js Project)
│       ├── src
│       │   ├── ai (OpenAI, Qdrant logic)
│       │   ├── ones (1C Integration)
│       │   ├── auth (Supabase Guard)
│       │   └── main.ts
├── shared
│   └── types (Общие интерфейсы для документов и товаров)
├── .env (Ключи: OPENAI, SUPABASE, QDRANT, ONE_C_URL)
└── README.md
Чек-лист разработки (Speed-run для хакатона)
Этот список поможет тебе не утонуть в деталях и двигаться по критическому пути.
Этап 1: Инфраструктура (День 1, утро)
[ ] Развернуть шаблон Expo в Replit.
[ ] Настроить проект Nest.js в той же или соседней папке.
[ ] Создать проект в Supabase (включить Auth и Database).
[ ] Подключить Qdrant Cloud (создать коллекцию kb_jarvis).
Этап 2: Ядро связи (День 1, вечер)
[ ] Написать в Nest.js метод /api/chat, принимающий messages.
[ ] Реализовать Function Calling для связи GPT с 1С (начать с функции get_stock).
[ ] Пробросить туннель к локальной 1С (если нужно) через Cloudflare или ngrok.
Этап 3: Мобильный интерфейс (День 2, утро)
[ ] Установить Tamagui и настроить тему.
[ ] Интегрировать react-native-gifted-chat с твоим бэкендом.
[ ] Добавить expo-av для записи голоса и отправки на бэкенд.
Этап 4: Vision и Финиш (День 2, вечер)
[ ] Реализовать загрузку фото в чат и обработку через GPT-4o-mini Vision.
[ ] Добавить "Библиотекаря" (поиск в Qdrant через embeddings).
[ ] Тестирование на реальном устройстве через Expo Go.
[ ] Запись демо-видео для конкурса.
Твой первый шаг: Boilerplate для Mobile
Чтобы ты сразу почувствовал скорость, вот пример того, как будет выглядеть твой основной экран чата с использованием выбранного стека.
<example>import React, { useState, useCallback } from &#39;react&#39;;
import { GiftedChat } from &#39;react-native-gifted-chat&#39;;
import { useChat } from &#39;ai/react&#39;; // Часть Vercel AI SDK
import { YStack, Button, Text } from &#39;tamagui&#39;; // UI Kit

export default function JarvisChat() {
const [messages, setMessages] = useState([]);

// Функция отправки сообщения к твоему Nest.js API
const onSend = useCallback(async (newMessages = []) =\> {
setMessages(previousMessages =\> GiftedChat.append(previousMessages, newMessages));

Архитектура «Бюджетной Универсальности»
Чтобы сделать систему универсальной и позволить юзеру подключать свои LLM и свои ERP, не переписывая код, мы используем три концепции:
1. BYO-LLM (Bring Your Own LLM)
Большинство провайдеров (Groq, Together AI, OpenRouter, Ollama) поддерживают OpenAI-compatible API.
Реализация: В приложении создаем экран Settings, где юзер вводит:
Base URL (например, http://localhost:11434/v1 для Ollama или https://api.groq.com).
API Key.
Model Name (например, llama3-70b).
Код: Твой Vercel AI SDK просто меняет baseURL в конфигурации. Это 15 минут работы.
2. Универсальный ERP-коннектор (The Adapter)
Вместо того чтобы учить модель работать с «1С», мы учим её работать с OpenAPI (Swagger).
Фишка: Юзер дает ссылку на JSON-спецификацию своей системы.
Процесс: Твой бэкенд на Nest.js парсит этот JSON и динамически генерирует Tools (Function Calling) для модели.
Результат: Если в API его бухгалтерии есть метод /create_invoice, ИИ сам увидит его и поймет, какие поля туда передать.
3. MCP (Model Context Protocol) — Твой козырь
Интегрируй поддержку MCP. Это позволит пользователям просто подключать готовые «серверы» для Google Sheets, PostgreSQL или любой ERP. Replit активно поддерживает этот стандарт.
План «Успеть всё» (High-Impact MVP)